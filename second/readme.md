B. Торрент-клиент
Условие
Вы решили написать свой торрент-клиент. Его особенностью будет то, что с его помощью можно передавать только текст.

Торрент-клиент почти готов, осталось самое главное: собрать исходный текст из кусков, на которые он был разбит для передачи.

Напишите функцию, которая дождется загрузки всех кусков текста и соберет из них исходную.

Функция принимает на вход объект с двумя полями: chunkCount и emitter, и возвращает промис, содержащий либо исходный текст, либо ошибку в виде строки заданного формата.

chunkCount — количество кусков, на которое был разбит текст.

У каждого куска текста есть уникальный идентификатор и время отправки. Куски с более поздним временем отправки располагаются дальше от начала текста.

emitter — объект, с помощью которого можно получать загруженные куски текста. Куски текста могут приходить с произвольными временными задержками. Порядок кусков может быть любым.

Если один и тот же кусок текста будет получен дважды до того, как загрузка успешно завершилась, функция должна выдать ошибку "Duplicate: " (с id куска текста на месте ).

Как только все куски текста были получены, необходимо соединить их в одну строку и вернуть эту строку с помощью промиса. Если у двух кусков времена отправки совпадают, порядок этих кусков в возвращенной строке может быть любым.

Если в течение секунды передача не завершилась, функция должна выдать ошибку "Timed out".

Входные данные соответствуют такому интерфейсу на TypeScript

(Общее описание интерфейсов TS)

    interface Input {
	    chunkCount: number;
	    emitter: Emitter;
	}

	interface Emitter {
		on: (callback: (chunk: Chunk) =>  void) => void;
	}

	interface Chunk {
		id: number;
		timestamp: Date;
		data: string;
	}
Решение необходимо предоставить в виде CommonJS-модуля:

    module.exports = function ({chunkCount, emitter}) {
	    // возвращает Promise
	};
Вердикт RE также означает, что отправленное решение неверно.